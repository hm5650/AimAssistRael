local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local Teams = game:GetService("Teams")
local localPlayer = Players.LocalPlayer

local function ShowNotification(title, text, duration)
    StarterGui:SetCore("SendNotification", {
        Title = title;
        Text = text;
        Duration = duration;
    })
end

ShowNotification("Made By hmmm5650", "haxczðŸ˜Ž", 5)
task.wait()

local player = game.Players.LocalPlayer
local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")

-- UI Elements
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = player:WaitForChild("PlayerGui")
screenGui.ResetOnSpawn = false -- Prevents UI from resetting when respawning

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 99, 0, 44)
frame.Position = UDim2.new(0, 115, 0, 49)
frame.AnchorPoint = Vector2.new(0.5, 1) -- Anchors the frame to the bottom center
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BackgroundTransparency = 0.2
frame.Active = true -- Necessary for Input events to work
frame.Parent = screenGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0.8, 0)
uiCorner.Parent = frame

local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(1, 0, 1, 0)
toggleButton.Text = "Aim Assist"
toggleButton.BackgroundTransparency = 1
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.TextSize = 10 -- Set the text size to 16
toggleButton.Parent = frame

local uiStroke = Instance.new("UIStroke")
uiStroke.Thickness = 2
uiStroke.Color = Color3.fromRGB(255, 255, 0)
uiStroke.Enabled = false
uiStroke.Parent = frame

-- Toggle Logic
local aimAssistEnabled = false
toggleButton.MouseButton1Click:Connect(function()
    aimAssistEnabled = not aimAssistEnabled
    uiStroke.Enabled = aimAssistEnabled
end)

-- Aim Assist Logic
local function isEnemy(otherPlayer)
    -- Check if the game is team-based
    if game:GetService("Teams") and #game:GetService("Teams"):GetTeams() > 1 then
        -- Team-based game: target players on the opposite team
        local playerTeam = player.Team
        local otherPlayerTeam = otherPlayer.Team
        return playerTeam ~= nil and otherPlayerTeam ~= nil and playerTeam ~= otherPlayerTeam
    else
        -- Non-team game: target all other players
        return otherPlayer ~= player
    end
end

local function isVisible(targetPosition, targetCharacter)
    local localCharacter = player.Character
    if not localCharacter then return false end
    local localRoot = localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRoot then return false end

    -- Raycast from the local player to the target position
    local ray = Ray.new(localRoot.Position, (targetPosition - localRoot.Position).Unit * 1000)
    local hit, position = workspace:FindPartOnRay(ray, localCharacter)

    -- If the ray hits something, check if it's the target
    if hit then
        if hit:IsDescendantOf(targetCharacter) then
            return true -- No wall in between
        else
            return false -- Wall detected
        end
    end
    return false
end

local function findNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = math.huge
    local localCharacter = player.Character
    if not localCharacter then return nil end
    local localRoot = localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRoot then return nil end

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if isEnemy(otherPlayer) and otherPlayer.Character then
            local character = otherPlayer.Character
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local distance = (localRoot.Position - rootPart.Position).Magnitude
                if distance < shortestDistance and isVisible(rootPart.Position, character) then
                    shortestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    return nearestPlayer
end

runService.RenderStepped:Connect(function()
    if aimAssistEnabled then
        local nearestPlayer = findNearestPlayer()
        if nearestPlayer and nearestPlayer.Character then
            local targetRoot = nearestPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                -- Adjust the player's aim (this is game-specific and may require additional logic)
                local camera = workspace.CurrentCamera
                if camera then
                    -- Smoothly adjust the camera to look at the target
                    local targetPosition = targetRoot.Position
                    local cameraPosition = camera.CFrame.Position
                    local newCFrame = CFrame.new(cameraPosition, targetPosition)
                    camera.CFrame = camera.CFrame:Lerp(newCFrame, 0.3) -- Smooth transition
                end
            end
        end
    end
end)

-- Dragging System
local dragging = false
local dragStart = Vector2.new(0, 0)
local startPos = UDim2.new(0, 0, 0, 0)

frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
    end
end)

frame.InputChanged:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and dragging then
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

userInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)
